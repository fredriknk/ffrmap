
// Map Initialization
var map = L.map('map').setView([59.664024053333335, 10.762923273333334], 17);

// Base Layer for the Map
var baselayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxNativeZoom: 19,  // The highest zoom level with actual tiles from the server
    maxZoom: 21,
}).addTo(map);

// Custom Tile Layer
var mytile = L.tileLayer('/static/Mapnik/{z}/{x}/{y}.jpg', {
    maxZoom: 21,
    tms: false,
    attribution: 'Generated by QTiles'
}).addTo(map);

// Layer Control
L.control.layers({'Basemap': baselayer}, {'Mapnik': mytile}).addTo(map);

// Global Variables
var breadcrumbs = [];
var stationaryStart = null;
var stationaryWarningTime = 240000; // 240 seconds (4 minutes) in milliseconds
var currentColoringMode = 'time'; // Default coloring mode

// Function to update breadcrumbs and check for stationary status
function updateBreadcrumbs(latestData) {
    if (shouldAddBreadcrumb(latestData)) {
        addBreadcrumb(latestData);
        resetStationaryStart();
    } else {
        checkStationaryStatus(latestData.timestamp);
    }
}

// Fetch and update map data
function updateMap() {
    fetch('/coords')
        .then(response => response.json())
        .then(data => handleData(data))
        .catch(error => handleDataError(error));
}

// Handle fetched data
function handleData(data) {
    if (data && data.length > 0) {
        updateGPSInfo(data[0]);
        updateBreadcrumbs(data[0]);
    }
}

// Update GPS information display
function updateGPSInfo(latestData) {
    document.getElementById('fix-quality').textContent = latestData.fix_quality;
    document.getElementById('satellites').textContent = latestData.sattelites;
}

// Check if a new breadcrumb should be added
function shouldAddBreadcrumb(latestData) {
    // Add breadcrumb if there are too few
    if (breadcrumbs.length <= 2) return true;

    // Calculate distance to the last breadcrumb
    var lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];
    var distance = getDistanceBetweenPoints(
        lastBreadcrumb.marker.getLatLng().lat,
        lastBreadcrumb.marker.getLatLng().lng,
        latestData.latitude,
        latestData.longitude
    );

    return distance >= 0.3; // Add breadcrumb if moved 0.3 units
}

// Reset the stationary start time
function resetStationaryStart() {
    stationaryStart = null;
    document.getElementById('stationary-time').textContent = '-';
    hideWarning();
}

function updateStationaryTime() {
    if (standstill > 5 && stationaryStart) {
        const elapsedStationaryTime = Math.floor((new Date() - stationaryStart) / 1000);
        document.getElementById('stationary-time').textContent = elapsedStationaryTime + ' seconds';
    }
    else{
        document.getElementById('stationary-time').textContent = 0;
    }
}

function handleDataError(error) {
    console.error("Error fetching coordinates:", error);
    document.getElementById('fix-quality').textContent = 'NO GPS';
    document.getElementById('satellites').textContent = 'NO GPS';
    document.getElementById('stationary-time').textContent = '-';
}

// Check if the rover has been stationary for too long
function checkStationaryStatus(currentTimestampString) {
    var currentTimestamp = new Date(currentTimestampString);
    if (!stationaryStart) {
        stationaryStart = currentTimestamp;
    } else if (currentTimestamp - stationaryStart > 5000) {
        const elapsedStationaryTime = Math.floor((currentTimestamp - stationaryStart) / 1000);
        document.getElementById('stationary-time').textContent = elapsedStationaryTime + ' seconds';
    } else if (currentTimestamp - stationaryStart > stationaryWarningTime) {
        // Rover has been stationary for too long
        alert('Rover stationary warning!');
    }
}
function clearBreadcrumbs() {
    breadcrumbs.forEach(breadcrumb => {
        map.removeLayer(breadcrumb.marker);
    });
    breadcrumbs = [];
    localStorage.removeItem('breadcrumbs');
}

function loadBreadcrumbs() {
    var breadcrumbData = JSON.parse(localStorage.getItem('breadcrumbs')) || [];
    breadcrumbData.forEach(data => {
        var marker = singleCrumb({
            latitude: data.lat,
            longitude: data.lng,
            timestamp: new Date(data.timestamp),
            fix_quality: data.fix_quality,
            sattelites: data.sattelites
        });

        breadcrumbs.push({
            marker: marker,
            timestamp: new Date(data.timestamp),
            fix_quality: data.fix_quality,
            sattelites: data.sattelites
        });
    });
}
function singleCrumb(coord){
    var newLatLng = new L.LatLng(coord.latitude, coord.longitude);
    var timestamp = new Date(coord.timestamp);
    var ageInSeconds = (new Date() - timestamp) / 1000;
    var color = getcolor({timestamp: timestamp,
        fix_quality: coord.fix_quality,
        sattelites: coord.sattelites
    }) ;

    var breadcrumbMarker = L.circleMarker(newLatLng, {
        radius: 4,
        fillColor: color,
        color: "#000",
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8
    }).addTo(map);

    // Construct the popup content string
    var popupContent = 'Latitude: ' + coord.latitude.toFixed(6) +
                       '<br>Longitude: ' + coord.longitude.toFixed(6) +
                       '<br>Timestamp: ' + timestamp.toLocaleString() +
                       '<br>Fix Quality: ' + coord.fix_quality +
                       '<br>Satellites: ' + coord.sattelites;

    // Bind the popup to the marker
    breadcrumbMarker.bindPopup(popupContent);

    return breadcrumbMarker
}

// Function to add breadcrumbs to the map
function addBreadcrumb(data) {
    const coordsArray = Array.isArray(data) ? data : [data];
    coordsArray.forEach(coord => {
        var breadcrumbMarker = singleCrumb(coord);

        breadcrumbs.push({
            marker: breadcrumbMarker,
            timestamp: coord.timestamp,
            fix_quality: coord.fix_quality,
            sattelites: coord.sattelites
        });
    });

    updateBreadcrumbColors();
    saveBreadcrumbsToLocalStorage();
}
function saveBreadcrumbsToLocalStorage() {
    var breadcrumbData = breadcrumbs.map(breadcrumb => {
        return {
            lat: breadcrumb.marker.getLatLng().lat,
            lng: breadcrumb.marker.getLatLng().lng,
            timestamp: breadcrumb.timestamp,
            fix_quality: breadcrumb.fix_quality,
            sattelites: breadcrumb.sattelites
        };
    });
    localStorage.setItem('breadcrumbs', JSON.stringify(breadcrumbData));
}

function displayWarning() {
    var warningBanner = document.getElementById('warning-banner');
    if (!warningBanner) {
        warningBanner = document.createElement('div');
        warningBanner.id = 'warning-banner';
        warningBanner.textContent = 'WARNING: Rover is stationary!';
        warningBanner.style.position = 'absolute';
        warningBanner.style.top = '10px';
        warningBanner.style.width = '100%';
        warningBanner.style.backgroundColor = 'red';
        warningBanner.style.color = 'white';
        warningBanner.style.textAlign = 'center';
        warningBanner.style.padding = '10px';
        warningBanner.style.zIndex = '1000'; // Make sure it's on top
        warningBanner.style.fontSize = '24px'; // Large text
        document.body.appendChild(warningBanner);
    }
}
//function to calculate distance between lattitude and longitude
function getDistanceBetweenPoints(lat1, lon1, lat2, lon2)
{
  var R = 6371e3; // km
  var dLat = toRad(lat2-lat1);
  var dLon = toRad(lon2-lon1);
  var lat1 = toRad(lat1);
  var lat2 = toRad(lat2);

  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  var d = R * c;
  return d;
}

// Converts numeric degrees to radians
function toRad(Value)
{
    return Value * Math.PI / 180;
}
function hideWarning() {
    var warningBanner = document.getElementById('warning-banner');
    if (warningBanner) {
        warningBanner.parentNode.removeChild(warningBanner);
    }
}

function getcolor(breadcrumb){
    var color;
        switch (currentColoringMode) {
            case 'time':
                var ageInSeconds = (new Date() - new Date(breadcrumb.timestamp)) / 1000;
                color = colorByTime(ageInSeconds);
                break;
            case 'fix':
                color = colorByFixQuality(breadcrumb.fix_quality);
                break;
            case 'satellite':
                color = colorBySatelliteCount(breadcrumb.sattelites);
                break;
        }
    return color;
}

const colorMappings = {
    time: {
        '< 1 min': '#00ff00',
        '1-4 min': '#ffff00',
        '> 4 min': '#ff0000'
    },
    fix: {
        'Invalid/No Fix': '#000000',
        'Standard GPS Fix (SPS)': '#ad0000',
        'Differential GPS Fix (DGPS)': '#ff4d00',
        'Precise Positioning Service (PPS) Fix': '#002afc',
        'Real Time Kinematic (RTK)': '#67ff00',
        'Float RTK': '#ffdd00',
        'Estimated/Manual/Simulation': '#808080'
    },
    satellite: {
         '> 30 Satellites':  '#00ff00', // Green for 30+ satellites
        '25-30 Satellites': '#00fcc1', // Teal for 25-30 satellites
        '20-25 Satellites': '#0077ff', // Blue for 20-25 satellites
        '15-20 Satellites': '#e600ff', // Dark orange for 15-20 satellites
        '10-15 Satellites': '#ff0062', // Orange-red for 10-15 satellites
        '< 10 Satellites':  '#ff0000'  // Red for less than 10 satellites
    }
};

function updateLegend() {
    let legendHtml = '';
    const currentMapping = colorMappings[currentColoringMode];
    for (const key in currentMapping) {
        legendHtml += `<div><span style="background-color: ${currentMapping[key]}; width: 20px; height: 20px; display: inline-block; margin-right: 5px;"></span>${key}</div>`;
    }
    document.getElementById('legend').innerHTML = legendHtml;
}

function updateBreadcrumbColors() {
    breadcrumbs.forEach(breadcrumb => {
        breadcrumb.marker.setStyle({ fillColor: getcolor(breadcrumb) });
    });
}

function colorByTime(ageInSeconds) {
    if (ageInSeconds < 60) {
        return '#00ff00';
    } else if (ageInSeconds < stationaryWarningTime / 1000) {
        return '#ffff00';
    } else {
        return '#ff0000';
    }
}

function colorByFixQuality(fixQuality) {
    switch (fixQuality) {
        case 0: // Invalid or no fix
            return '#000000'; // Black
        case 1: // Standard GPS fix (SPS)
            return '#ad0000'; // Red
        case 2: // Differential GPS fix (DGPS)
            return '#ff4d00'; // Orange
        case 3: // Precise Positioning Service (PPS) fix
            return '#002afc'; // Blue
        case 4: // Real Time Kinematic (RTK)
            return '#67ff00'; // Green
        case 5: // Float RTK
            return '#ffdd00'; // Yellow
        case 6: // Estimated (dead reckoning)
            return '#808080'; // Grey
        case 7: // Manual input mode
            return '#808080'; // Grey
        case 8: // Simulation mode
            return '#808080'; // Grey
        default:
            return '#808080'; // Default color (Grey) for unknown fix types
    }
}

function colorBySatelliteCount(satellites) {
    const sats = parseInt(satellites, 10);
    const colorStops = [
        { threshold: 0, color: '#ff0000' },  // Red for 0 satellites
        { threshold: 10, color: '#ff0062' }, // Orange-red for 10 satellites
        { threshold: 15, color: '#e600ff' }, // Dark orange for 20 satellites
        { threshold: 20, color: '#0077ff' }, // Gold for 30 satellites
        { threshold: 25, color: '#00fcc1' }, // Yellow-green for 35 satellites
        { threshold: 30, color: '#00ff00' }  // Green for 40 satellites
    ];

    for (let i = 0; i < colorStops.length - 1; i++) {
        const currentStop = colorStops[i];
        const nextStop = colorStops[i + 1];

        if (sats >= currentStop.threshold && sats < nextStop.threshold) {
            // Calculate interpolation factor
            let factor = (sats - currentStop.threshold) / (nextStop.threshold - currentStop.threshold);
            return interpolateColor(currentStop.color, nextStop.color, factor);
        }
    }

    return colorStops[colorStops.length - 1].color; // Return the last color if above all thresholds
}
function interpolateColor(color1, color2, factor) {
    var result = "#";
    for (var i = 1; i <= 5; i += 2) {
        var color1Part = parseInt(color1.substr(i, 2), 16);
        var color2Part = parseInt(color2.substr(i, 2), 16);
        var mix = Math.round(color1Part * (1 - factor) + color2Part * factor);
        result += ('0' + mix.toString(16)).slice(-2);
    }
    return result;
}

function setColoringMode(mode) {
    currentColoringMode = mode;
    updateBreadcrumbColors();
    updateButtonStyles();
    updateLegend();
}

function updateButtonStyles() {
    document.getElementById('timeColoring').classList.remove('active');
    document.getElementById('fixQualityColoring').classList.remove('active');
    document.getElementById('satelliteColoring').classList.remove('active');

    if (currentColoringMode === 'time') {
        document.getElementById('timeColoring').classList.add('active');
    } else if (currentColoringMode === 'fix') {
        document.getElementById('fixQualityColoring').classList.add('active');
    } else if (currentColoringMode === 'satellite') {
        document.getElementById('satelliteColoring').classList.add('active');
    }
}

// Initialize the map with stored breadcrumbs
loadBreadcrumbs();

document.getElementById('fetchButton').addEventListener('click', function() {
    // Append a unique timestamp to the request URL
    var timestamp = new Date().getTime();
    var backendUrl = '/image?_=' + timestamp;

    document.getElementById('fetchedImage').src = backendUrl;
});

document.addEventListener('DOMContentLoaded', function() {
    updateButtonStyles();
    updateLegend();
    setInterval(updateMap, 1000); // Update the map every second
});
